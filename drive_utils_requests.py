import os
import json
import base64
import time
import requests
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request as GoogleAuthRequest # Renamed to avoid conflict with requests.Request
from cryptography.fernet import Fernet

# Set SSL_CERT_FILE environment variable for proper SSL certificate handling.
# This ensures Python uses the CA certificates provided by certifi, which is crucial for
# avoiding SSL/TLS errors like CERTIFICATE_VERIFY_FAILED on Windows.
import certifi
os.environ['SSL_CERT_FILE'] = certifi.where() # Points to the cacert.pem file from certifi package

# Encryption key, must be identical on both client and server.
# IMPORTANT: Replace with your own securely generated key.
# You can generate a key using generate_key.py script: print(Fernet.generate_key().decode())
ENCRYPTION_KEY = b'YOUR_ACTUAL_ENCRYPTION_KEY_HERE_FROM_GENERATE_KEY_DOT_PY' 
fernet = Fernet(ENCRYPTION_KEY)

# Google Drive API scopes and token file path
SCOPES = ['https://www.googleapis.com/auth/drive'] # Full Drive access
TOKEN_FILE = 'token.json' # File to store authenticated user's tokens

# Base URLs for Google Drive API
GOOGLE_DRIVE_API = 'https://www.googleapis.com/drive/v3'
UPLOAD_API = 'https://www.googleapis.com/upload/drive/v3/files'


def get_token():
    """
    Loads Google OAuth2 credentials from token.json.
    Refreshes the access token if it's expired using the refresh token.
    If no valid token exists, it exits (primarily for server-side where interactive auth isn't possible).
    """
    creds = None
    if os.path.exists(TOKEN_FILE):
        creds = Credentials.from_authorized_user_file(TOKEN_FILE, SCOPES)
    
    # Check if credentials are valid and if not, try to refresh them
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            try:
                # Refresh the token using google.auth's Request object
                creds.refresh(GoogleAuthRequest()) 
            except Exception as e:
                # Log error and exit if refresh fails (common on server without browser)
                print(f"Error refreshing token: {e}. Token might be revoked or network issue.")
                exit("Authentication token refresh failed. Please generate a new token.json on client and transfer.")
        else:
            # If no valid creds and no refresh token (or first run on server without token.json)
            # On the server, we expect token.json to be pre-generated by client.py
            print(f"Error: No valid token found in {TOKEN_FILE}.")
            exit("Authentication token not found or invalid. Please ensure token.json is correctly set up from client.")

        # Save the updated/new credentials
        with open(TOKEN_FILE, 'w') as token_file_obj:
            token_file_obj.write(creds.to_json())

    return creds.token


def list_files_in_folder(folder_id):
    """
    Lists files within a specified folder in Google Drive.
    """
    token = get_token()
    headers = {"Authorization": f"Bearer {token}"}
    params = {
        "q": f"'{folder_id}' in parents and trashed=false",
        "fields": "files(id, name, createdTime)", # Include createdTime for sorting
        "pageSize": 100
    }
    response = requests.get(f"{GOOGLE_DRIVE_API}/files", headers=headers, params=params)
    if response.status_code == 200:
        return response.json().get('files', [])
    else:
        print(f"List files failed (HTTP {response.status_code}): {response.text}")
        return []


def upload_file(file_name, content_bytes, folder_id):
    """
    Uploads a file with specified byte content to a specific folder in Google Drive.
    If a file with the same name exists, it will be deleted first for simplicity.
    """
    token = get_token()
    headers = {"Authorization": f"Bearer {token}"}

    # Delete existing file with the same name in the target folder to avoid conflicts
    existing_files = list_files_in_folder(folder_id)
    for f in existing_files:
        if f['name'] == file_name:
            delete_file(f['id']) # Use the delete_file function

    # Metadata for the new file
    metadata = {
        'name': file_name,
        'parents': [folder_id]
    }
    
    # Prepare files dictionary for multipart/form-data upload using requests
    # 'metadata' and 'file' are the names of the multipart parts
    files_data = {
        'metadata': (None, json.dumps(metadata), 'application/json; charset=UTF-8'),
        'file': (file_name, content_bytes, 'application/octet-stream') # filename, content, content_type
    }

    # Perform the multipart upload
    response = requests.post(f"{UPLOAD_API}?uploadType=multipart", headers=headers, files=files_data)
    
    if response.status_code in [200, 201]:
        return response.json()['id']
    else:
        print(f"Upload failed (HTTP {response.status_code}): {response.text}")
        return None


def download_file(file_id):
    """
    Downloads a file from Google Drive by its ID and returns its content as bytes.
    """
    token = get_token()
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.get(f"{GOOGLE_DRIVE_API}/files/{file_id}?alt=media", headers=headers)
    if response.status_code == 200:
        return response.content
    else:
        print(f"Download failed (HTTP {response.status_code}): {response.text}")
        return None


def delete_file(file_id):
    """
    Deletes a file from Google Drive by its ID.
    Returns True on successful deletion or if the file was already not found (404).
    """
    token = get_token()
    headers = {"Authorization": f"Bearer {token}"}
    response = requests.delete(f"{GOOGLE_DRIVE_API}/files/{file_id}", headers=headers)
    if response.status_code in [204, 200]: # 204 No Content is standard for successful DELETE
        return True
    elif response.status_code == 404: # File already not found, consider it deleted
        print(f"Delete warning: File {file_id} not found (already deleted?).")
        return True
    else:
        print(f"Delete failed (HTTP {response.status_code}): {response.text}")
        return False


def encrypt_data(data_bytes):
    """
    Encrypts given byte data using Fernet symmetric encryption.
    """
    return fernet.encrypt(data_bytes)


def decrypt_data(encrypted_data_bytes):
    """
    Decrypts given encrypted byte data using Fernet symmetric encryption.
    Handles potential decryption errors (e.g., corrupted data, wrong key).
    """
    try:
        return fernet.decrypt(encrypted_data_bytes)
    except Exception as e:
        print(f"Decryption error: {e}")
        return None